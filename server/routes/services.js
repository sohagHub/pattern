/**
 * @file Defines all routes for the Services route.
 */

const express = require('express');
const fetch = require('node-fetch');

const router = express.Router();

const { asyncWrapper } = require('../middleware');
const plaid = require('../plaid');
const {
  handleTransactionsWebhook,
  handleItemWebhook,
  unhandledWebhook,
} = require('../webhookHandlers');

const {
  retrieveItemsByUser,
  retrieveItemByPlaidAccessToken,
  retrieveTransactionsByUserId,
} = require('../db/queries');

const updateTransactions = require('../update_transactions');
const {
  retrieveTransactionById,
  justUpdateTransactions,
  applyRulesForCategory,
  createRule,
  updateRule,
  deleteRule,
  retrieveRuleById,
} = require('../db/queries/transactions');

const { get } = require('lodash');
const { getInstitutionById, processWithConcurrencyLimit } = require('../util');


/**
 * Returns the URL of the current public endpoint generated by ngrok.
 *
 * @returns {Object} the public endpoint currently active.
 */
router.get(
  '/ngrok',
  asyncWrapper(async (req, res) => {
    const response = await fetch('http://localhost:4040/api/tunnels');
    const { tunnels } = await response.json();
    const httpTunnel = tunnels.find(t => t.proto === 'http');
    res.json({ url: httpTunnel.public_url });
  })
);

/**
 * Handles incoming webhooks from Plaid.
 * https://plaid.com/docs/#webhooks
 */
router.post(
  '/webhook',
  asyncWrapper(async (req, res) => {
    const { webhook_type: webhookType } = req.body;
    const { io } = req;
    const type = webhookType.toLowerCase();
    // There are five types of webhooks: AUTH, TRANSACTIONS, ITEM, INCOME, and ASSETS.
    // @TODO implement handling for remaining webhook types.
    const webhookHandlerMap = {
      transactions: handleTransactionsWebhook,
      item: handleItemWebhook,
    };
    const webhookHandler = webhookHandlerMap[type] || unhandledWebhook;
    webhookHandler(req.body, io);
    res.json({ status: 'ok' });
  })
);

router.put(
  '/transaction/:id',
  asyncWrapper(async (req, res) => {
    const id = req.params.id;
    const item = await retrieveTransactionById(id);
    // if not empty update
    item.name = req.body.name ? req.body.name : item.name;
    item.category = req.body.category ? req.body.category : item.category;
    item.subcategory = req.body.subcategory ? req.body.subcategory : item.subcategory;
    item.mark_delete = req.body.mark_delete ? req.body.mark_delete : item.mark_delete;
    item.date = req.body.date ? req.body.date : item.date;
    await justUpdateTransactions([item]);
    res.json({ status: 'ok' });

  })
);

router.put(
  '/:userId/rule/:id',
  asyncWrapper(async (req, res) => {
    console.log(req.body);
    const id = req.params.id;
    let item = await retrieveRuleById(id);

    // if not empty update
    item.name = req.body.name ? req.body.name : item.name;
    item.category = req.body.category ? req.body.category : item.category;
    item.subcategory = req.body.subcategory ? req.body.subcategory : item.subcategory;
    item.newName = req.body.new_name ? req.body.new_name : item.new_name;
    item.newCategory = req.body.new_category ? req.body.new_category : item.new_category;
    item.newSubcategory = req.body.new_subcategory ? req.body.new_subcategory : item.new_subcategory;
    item.serial = req.body.serial ? req.body.serial : item.serial;

    await updateRule(item);

    res.json({ status: 'ok' });
  })
);

router.post(
  '/:userId/rule',
  asyncWrapper(async (req, res) => {
    console.log(req.body);
    const userId = req.params.userId;
    let item = {};
    // if not empty update
    item.name = req.body.name;
    item.category = req.body.category;
    item.subcategory = req.body.subcategory;
    item.newName = req.body.new_name;
    item.newCategory = req.body.new_category;
    item.newSubcategory = req.body.new_subcategory;
    item.serial = req.body.serial;
    item.userId = userId;

    // if name, category, subcategory all are null, return error
    if (!item.name && !item.category && !item.subcategory) {
      res.json({ status: 'error', message: 'name, category, and subcategory - all cannot be empty' });
      return;
    }

    await createRule(item);

    res.json({ status: 'ok' });
  })
);

router.delete(
  '/:userId/rule/:id',
  asyncWrapper(async (req, res) => {
    const id = req.params.id;
    await deleteRule(id);
    res.json({ status: 'ok' });
  })
);

router.put(
  '/updateTransactionsByRule/:userId',
  asyncWrapper(async (req, res) => {
    const { userId } = req.params;
    const transactions = await retrieveTransactionsByUserId(userId);
    const concurrency = 20; // Concurrency limit
    const batchSize = 100; // Batch size

    await processWithConcurrencyLimit(
      transactions,
      concurrency,
      batchSize,
      async batch => {
        const updatedTransactions = await Promise.all(
          batch.map(async transaction => {
            let {
              transactionName: name,
              category,
              subcategory,
            } = await applyRulesForCategory(
              transaction.name,
              transaction.category,
              transaction.subcategory
            );

            if (
              name !== transaction.name ||
              category !== transaction.category ||
              subcategory !== transaction.subcategory
            ) {
              transaction.name = name;

              if (transaction.category !== 'Duplicate') {
                transaction.category = category;
              }

              transaction.subcategory = subcategory;
            }

            return transaction;
          })
        );

        await justUpdateTransactions(updatedTransactions);
      }
    );
    
    req.io.emit('SYNC_COMPLETED', {
      userId: userId,
      log: 'Rules are applied',
    });

    console.log('done');
    res.json({ status: 'ok' });
  })
);

module.exports = router;
